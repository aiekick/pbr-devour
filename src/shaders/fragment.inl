#pragma data_seg(".shader")
const char* fragment =
 "#version 430\n"
 "layout(location=0)uniform int iFrame;"
 "layout(binding=0)uniform sampler2D roughnessTexture;"
 "layout(location=2)uniform vec2 resolution;"
 "const float pi=3.14159,pi2=2*pi;"
 "float maxcomp(vec3 p)"
 "{"
   "return max(p.x,max(p.y,p.z));"
 "}"
 "vec4 mmin(vec4 a,vec4 b)"
 "{"
   "return a.x<b.x?a:b;"
 "}"
 "vec4 mmax(vec4 a,vec4 b)"
 "{"
   "return a.x>b.x?a:b;"
 "}"
 "float box(vec3 p,vec3 b)"
 "{"
   "vec3 di=abs(p)-b;"
   "return maxcomp(di);"
 "}"
 "float hash13(vec3 p3)"
 "{"
   "return p3=fract(p3*.1031),p3+=dot(p3,p3.yzx+19.19),fract((p3.x+p3.y)*p3.z);"
 "}"
 "float seed;"
 "float hash()"
 "{"
   "vec3 p3=fract(vec3(seed++)*.1031);"
   "p3+=dot(p3,p3.yzx+19.19);"
   "return fract((p3.x+p3.y)*p3.z);"
 "}"
 "vec2 hash(float p)"
 "{"
   "vec3 p3=fract(vec3(p)*vec3(.1031,.103,.0973));"
   "p3+=dot(p3,p3.yzx+19.19);"
   "return fract((p3.xx+p3.yz)*p3.zy);"
 "}"
 "vec2 fc;"
 "float sd;"
 "vec2 hash2(float n)"
 "{"
   "return vec2(hash(),hash());"
 "}"
 "const float phi=1.32472,delta0=.76,i0=.7;"
 "const vec2 alpha=vec2(1/phi,1/phi/phi);"
 "float hash(uvec2 x)"
 "{"
   "uvec2 q=1103515245U*(x>>1U^x.yx);"
   "uint n=1103515245U*(q.x^q.y>>3U);"
   "return float(n)*(1/float(-1U));"
 "}"
 "vec2 hash22(vec2 p)"
 "{"
   "vec3 p3=fract(vec3(p.xyx)*vec3(.1031,.103,.0973));"
   "p3+=dot(p3,p3.yzx+19.19);"
   "return fract((p3.xx+p3.yz)*p3.zy);"
 "}"
 "vec2 R2_seq(int i,float lambda,float n)"
 "{"
   "vec2 u=vec2(hash(uvec2(i,0)),hash(uvec2(i,1)))-.5,s=fract(alpha*float(i)+lambda*1.34707/(4*sqrt(float(i)-i0))*u);"
   "s+=hash(n);"
   "s+=hash22(fc);"
   "return mod(s,1);"
 "}\n"
 "#define scale.7\n"
 "#define maxi 0.75\n"
 "#define fr_it 8\n"
 "vec4 map(vec3 p)"
 "{"
   "vec3 po=p;"
   "p=-p;"
   "float k=1,e=0;"
   "for(int i=0;i<fr_it;++i)"
     "{"
       "vec3 ss=vec3(-.54,.84,1.22);"
       "p=2*clamp(p,-ss,ss)-p;"
       "float f=max(scale/dot(p,p),maxi);"
       "p*=f;"
       "k*=f*1.05;"
       "e=f;"
     "}"
   "vec4 res=vec4(max(length(p.xz)-.9,length(p.xz)*abs(p.y)/length(p))/k,3,0,1);"
   "p=-p;"
   "res.x+=(-1+2*hash13(floor(p*10)))*.005*(1-step(.01,po.y));"
   "const float of=-1,l=.1;"
   "res.z=max(0,60*(smoothstep(of-l,of,p.y)-smoothstep(of,of+l,p.x)));"
   "res.z*=step(-1,po.z);"
   "const float ang=.04;"
   "const mat2 rot=mat2(cos(ang),sin(ang),-sin(ang),cos(ang));"
   "vec3 tpo=po-vec3(0,.12,-1.5);"
   "tpo.xy*=rot;"
   "float blast=pow(smoothstep(-1.6,.35,po.x)-smoothstep(.4,.48,po.x),3);"
   "res=mmin(res,vec4(length(tpo.yz)-.02*blast,2,mix(0,25,pow(blast,2)),0));"
   "res=mmin(res,vec4(po.y+.015,0,0,0));"
   "res=mmax(res,vec4(box(po,vec3(11,1,11)),3,0,1));"
   "res=mmin(res,vec4(length(po-vec3(-2.4,0,-5))-.4,vec3(0,30,0)));"
   "return mmin(res,vec4(length(po-vec3(-3.8,3,-2.7))-2.4,vec3(1,30,0)));"
 "}"
 "const float E=.00025;"
 "vec4 intersect(vec3 ro,vec3 rd)"
 "{"
   "float t=0;"
   "vec4 res=vec4(-1),h=vec4(1);"
   "for(int i=0;i<200;i++)"
     "{"
       "float eps=E+E*5*pow(float(i)/200,2);"
       "if(h.x<eps||t>15)"
         "break;"
       "h=map(ro+rd*t);"
       "res=vec4(t,h.yzw);"
       "t+=h.x;"
     "}"
   "return t>=15?vec4(-999):res;"
 "}"
 "vec3 calcNormal(vec3 p)"
 "{"
   "float c=map(p).x;"
   "const float e=1e-05;"
   "return normalize(vec3(c-map(p-vec3(e,0,0)).x,c-map(p-vec3(0,e,0)).x,c-map(p-vec3(0,0,e)).x));"
 "}"
 "vec3 lambert(in vec3 normal,in vec2 uv)"
 "{"
   "float theta=pi2*uv.x;"
   "uv.y=2*uv.y-1;"
   "vec3 spherePoint=vec3(sqrt(1-uv.y*uv.y)*vec2(cos(theta),sin(theta)),uv.y);"
   "return normalize(normal+spherePoint);"
 "}"
 "vec3 ggx(vec3 rd,vec3 n,float rgh,vec2 rand)"
 "{"
   "float s=-1+2*step(0,n.z),a=-1/(s+n.z),b=n.x*n.y*a;"
   "mat3 cs=mat3(vec3(1+s*n.x*n.x*a,s*b,-s*n.x),n,vec3(b,s+n.y*n.y*a,-n.y));"
   "float th=.5*pi*atan(rgh*sqrt(rand.x)/sqrt(1-rand.x));"
   "vec3 reflection=normalize(transpose(cs)*rd),normal_distribution=vec3(cos(pi2*rand.y)*sin(th),cos(th),sin(pi2*rand.y)*sin(th));"
   "return normalize(cs*reflect(reflection,normal_distribution));"
 "}"
 "vec3 brdf(in vec3 normal,in vec2 uv,in vec3 rd)"
 "{"
   "float theta=pi2*uv.x;"
   "uv.y=2*uv.y-1;"
   "vec3 p=vec3(sqrt(1-uv.y*uv.y)*vec2(cos(theta),sin(theta)),uv.y);"
   "float z=dot(p,normal);"
   "p-=z*normal;"
   "p/=sqrt(1-z*z);"
   "p*=(1-2*z+z*z)/4;"
   "p+=normal*sqrt(1-dot(p,p));"
   "vec3 ha=normalize(p);"
   "p=normalize(reflect(normalize(rd),p));"
   "return p;"
 "}"
 "vec3 colors[6];"
 "vec3 render(vec3 ro,vec3 rd,vec2 uv)"
 "{"
   "vec3 color=vec3(0),absorption=vec3(1);"
   "const int BOUNCES=4;"
   "for(int b=0;b<BOUNCES;b++)"
     "{"
       "sd+=1;"
       "vec4 tmat=intersect(ro,rd);"
       "if(tmat.x>=0)"
         "{"
           "vec3 pos=ro+tmat.x*rd,nor=calcNormal(pos);"
           "vec2 metal_coords=cross(nor,normalize(vec3(1,0,2))).xy;"
           "float rough_map=mix(texture(roughnessTexture,mod(metal_coords*1.21,1)).x,texture(roughnessTexture,mod(metal_coords*.53,1)).x,.7);"
           "rough_map=pow(1-rough_map,2);"
           "vec3 incoming=colors[int(tmat.y)];"
           "incoming*=1+.09*(1-2*rough_map)*step(1,tmat.w);"
           "vec3 emission=tmat.z*incoming;"
           "color+=absorption*emission;"
           "absorption*=incoming/pi;"
           "vec3 rv=reflect(rd,nor);"
           "float rough1=.01+.3*texture(roughnessTexture,mod(pos.xz*.7,1)).x;"
           "rough1=mix(rough1,.4,smoothstep(7,9,distance(ro,pos)));"
           "float rough2=mix(.04,.02+.04*pow(1-rough_map,2),step(.01,pos.y));"
           "vec3 metal=mix(brdf(nor,R2_seq(iFrame,.5,31.23+sd),rd),ggx(rd,nor,rough2,R2_seq(iFrame,.5,-43.531)),step(.45,hash())),ground=mix(lambert(nor,R2_seq(iFrame,.5,9531.53+sd)),ggx(rd,nor,rough1,R2_seq(iFrame,.5,86439.3)),step(.5,hash()));"
           "rd=mix(ground,metal,tmat.w);"
           "ro=pos+rd*E*20;"
         "}"
       "else"
         "{"
           "vec3 pos=ro+tmat.x*rd;"
           "color+=absorption*colors[4]*.9;"
           "break;"
         "}"
     "}"
   "return color;"
 "}"
 "void main()"
 "{"
   "colors[0]=1.25*vec3(.75,.52,.4).zyx;"
   "colors[1]=1.25*vec3(.75,.38,.2).zyx;"
   "colors[2]=vec3(.6,.32,.92).zyx;"
   "colors[3]=vec3(.42,.66,.95).zyx;"
   "colors[4]=normalize(vec3(3,1,.5)).zyx;"
   "colors[5]=vec3(1,.1,.04).zyx;"
   "const float aspect=resolution.x/resolution.y;"
   "vec2 uv=gl_FragCoord.xy/resolution.xy;"
   "vec3 ro=vec3(.6,.1,.7)*20;"
   "fc=gl_FragCoord.xy;"
   "vec3 col=vec3(0);"
   "seed=float((iFrame*73856093^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);"
   "vec3 ww=normalize(vec3(.76,.38,.1)-ro),uu=normalize(cross(normalize(vec3(0,1,0)),ww)),vv=normalize(cross(ww,uu));"
   "vec2 rand=hash2(0),p=-1+2*(uv+.667*(-1+2*hash2(3531.41))/resolution.xy);"
   "p.x*=aspect;"
   "vec2 lens_sample=vec2(cos(rand.x*pi2),sin(rand.x*pi2))*pow(rand.y,.32);"
   "lens_sample*=vec2(.75,1.333);"
   "vec3 lens_pos=ro+(lens_sample.x*uu+lens_sample.y*vv)*.1,vr=normalize(ro+(p.x*uu+p.y*vv+40*ww)*.45-lens_pos);"
   "gl_FragColor.xyz=min(render(lens_pos+17.3*vr,vr,p),15);"
 "}";
